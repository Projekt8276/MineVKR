#version 460 core // #
#extension GL_GOOGLE_include_directive : require
#extension GL_NV_ray_tracing           : require
#include "./driver.glsl"


//#define ENABLE_RASTERIZE_STAGE
layout ( binding = 2, set = 1 ) uniform accelerationStructureNV Scene;
layout ( location = 0 ) rayPayloadNV RayPayloadData PrimaryRay;
#define ShadowsRay PrimaryRay // re-direct
//layout ( location = 1 ) rayPayloadNV RayPayloadData ShadowsRay;


vec4 shiftByPixel(in vec4 wpos, inout uvec2 seed){
    vec2 sizpx = vec2(gl_LaunchSizeNV.xy);
    vec2 shift = random2(seed);
    vec4 sspos = vec4(vec4(divW(wpos * projectionInv),1.f) * modelviewInv, 1.f);
    sspos.xy += shift/sizpx;
    return vec4(divW(vec4(sspos * modelview, 1.f) * projection), 1.f);
};


// TODO: Hybrid Path Tracing
void main() { // Hi-DPI adaptation
    ShadowsRay.position  = PrimaryRay.position  = vec4(0.f);
    ShadowsRay.specular  = PrimaryRay.specular  = vec4(0.f);
    ShadowsRay.diffuse   = PrimaryRay.diffuse   = vec4(0.f);
    ShadowsRay.normals   = PrimaryRay.normals   = vec4(0.f);
    ShadowsRay.normalm   = PrimaryRay.normalm   = vec4(0.f);
    ShadowsRay.fdata.xyz = PrimaryRay.fdata.xyz = vec3(0.f,0.f,10000.f); //gl_HitTNV
    ShadowsRay.udata.xyz = PrimaryRay.udata.xyz = uvec3(0u);

    // 
    const ivec2 curPixel = ivec2(gl_LaunchIDNV.xy), invPixel = ivec2(curPixel.x,gl_LaunchSizeNV.y-curPixel.y-1u);
    const ivec2 sizPixel = ivec2(gl_LaunchSizeNV.xy);
    const uint packed = pack32(u16vec2(curPixel));

    // 
    const Box box = { -1.f.xxx, 1.f.xxx }; // TODO: Change Coordinate
    const vec4 sphere = vec4(vec3(8.f,8.f,4.f), 4.f); 
    const vec3 lightc = 10.f.xxx;

    //const vec2 shift = random2(uvec2(rdata[0],packed)), pixel = (vec2(invPixel)+0.5f)+(shift*2.f-1.f)*0.5f;
    const vec2 shift = 0.5f.xx, pixel = (vec2(invPixel)+0.5f)+(shift*2.f-1.f)*0.5f;
    const vec4 colourSample = texture(frameBuffers[COLORING], pixel);
    const vec4 normalSample = texture(frameBuffers[NORMALED], pixel);
    const vec4 worldsSample = texture(frameBuffers[POSITION], pixel);
    const vec4 emitedSample = texture(frameBuffers[EMISSION], pixel);
    const vec4 speculSample = texture(frameBuffers[SPECULAR], pixel);
    const vec3 cameraSample = vec4(worldsSample.xyz,1.f)*modelview;
    uvec2 seed = uvec2(packed,rdata.x);

    const int ITERATION_COUNT = 2;
    const int TRANSPARENT_COUNT = 2;

    [[unroll]] for (uint32_t I=0;I<2;I++) { // Path Traced Diffuse Global Illumination
        int TRANSPARENT_ITERATION = TRANSPARENT_COUNT;

#ifdef ENABLE_RASTERIZE_STAGE
        vec3 raydir  = (modelview * normalize(cameraSample.xyz)).xyz;
        vec3 origin  = worldsSample.xyz;
        vec3 normal = normalSample.xyz;
#else
        vec3 origin = screen2world(vec3((vec2(pixel)/vec2(sizPixel))*2.f-1.f,0.001f));
        vec3 target = screen2world(vec3((vec2(pixel)/vec2(sizPixel))*2.f-1.f,0.999f));
        vec3 raydir = normalize(target - origin);
        vec3 normal = vec3(0.f);
#endif

        const float inIOR = 1.f;
        const float outIOR = 1.333f;
        vec3 forign = origin.xyz;
        vec3 fnorml = normal.xyz;
        float frefl = mix(clamp(pow(1.0f + dot(raydir.xyz, normal.xyz), outIOR/inIOR), 0.f, 1.f) * 0.5f, 1.f,speculSample.z);

        //
        vec4 gNormal = vec4(normal,0.f);
        vec4 gSignal = vec4(0.f.xxx,1.f);
        vec3 gEnergy = I == 0 ? 1.f.xxx : mix(1.f.xxx, colourSample.xyz + emitedSample.xyz, speculSample.z);
        vec2 gTexcoord = 0.f.xx;

        int i = 0; 
#ifdef ENABLE_RASTERIZE_STAGE // complete first stage
        gNormal.xyz = faceforward(gNormal.xyz, raydir.xyz,gNormal.xyz); 
        raydir.xyz = I == 0 ? randomHemisphereCosine(gNormal.xyz,seed) : reflectGlossy(raydir.xyz, gNormal.xyz, seed, speculSample.y);
        origin.xyz += faceforward(gNormal.xyz,-raydir.xyz,gNormal.xyz) * 0.0001f, i++; // pre-correction
#endif

        bool afterReflection = false;

        //if (!all(fequal(worldsSample.xyz,0.f.xxx)) && (I == 0u || frefl >= 0.001f)) 
        for (;i <= ITERATION_COUNT; i++) { //

            // Shadows Rays
            if (i >= (I == 0 ? 1u : 2u)) {
                vec3 lorign = origin;
                const vec3 lightp = sphere.xyz + randomSphere(seed) * sphere.w; float shdist = distance(lightp.xyz,lorign.xyz);
                const vec3 lightd = normalize(lightp.xyz - lorign.xyz);
                
                float sdepth = raySphereIntersect(origin.xyz,lightd,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
                float depth = 0.f;
                for (uint j=0;j<TRANSPARENT_COUNT;j++) {
                    traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
                        0, 1, 0,
                        lorign.xyz, 0.0001f,
                        lightd.xyz, 10000.f,
                        1);
                    
                    depth = min(sdepth,depth+ShadowsRay.fdata.z); // Generalize Shadow Depth
                    lorign.xyz += lightd.xyz * ShadowsRay.fdata.z;
                    if (ShadowsRay.diffuse.w > 0.001f || depth >= (shdist-0.0001f)) { break; };
                    lorign.xyz += faceforward(ShadowsRay.normals.xyz,-lightd.xyz,ShadowsRay.normals.xyz) * 0.0001f;
                };

                const float cos_a_max = sqrt(1.f - clamp(sphere.w * sphere.w / dot(sphere.xyz-origin.xyz, sphere.xyz-origin.xyz), 0.f, 1.f));
                if (depth >= (shdist-sphere.w-0.0001f)) { gSignal += vec4(gEnergy * 2.f * (1.f - cos_a_max) * clamp(dot( lightd, gNormal.xyz ), 0.f, 1.f) * lightc, 0.f); };
            };

            // Primary Rays
            traceNV(Scene, gl_RayFlagsOpaqueNV, 0xFF,
                0, 1, 0,
                origin.xyz, 0.0001f,
                raydir.xyz, 10000.f,
                0);
            
            gNormal = PrimaryRay.normalm;
            const vec4  diffuseColor = PrimaryRay.diffuse;
            const vec4 emissionColor = PrimaryRay.emission;
            const vec4 specularColor = PrimaryRay.specular;

            // 
            float sdepth = raySphereIntersect(origin.xyz,raydir.xyz,sphere.xyz,sphere.w); sdepth = sdepth <= 0.f ? 10000.f : sdepth;
            float pdepth = planeIntersect(origin.xyz,raydir.xyz,vec3(0.f,-5.f,0.f),vec3(0.f,1.f,0.f)); pdepth = pdepth <= 0.f ? 10000.f : pdepth;
            float  depth = afterReflection && I == 0u ? min(PrimaryRay.fdata.z,sdepth) : PrimaryRay.fdata.z;

            // power of reflection
            float reflectionPower = mix(clamp(pow(1.0f + dot(raydir.xyz, gNormal.xyz), outIOR/inIOR), 0.f, 1.f) * 0.5f, 1.f, specularColor.z);
            bool couldReflection = random(seed) <= reflectionPower;

            // TODO: better depth system
            [[flatten]] if (depth >= 9999.f) { BACKSKY_COLOR; };
            [[flatten]] if (depth == PrimaryRay.fdata.z) { if (diffuseColor.w > 0.001f) {
                if (couldReflection) {
                    gEnergy *= mix(1.f.xxx,diffuseColor.xyz,specularColor.zzz);
                } else {
                    gSignal.xyz += gEnergy.xyz * emissionColor.xyz * emissionColor.w;
                    gEnergy *= max(diffuseColor.xyz - clamp(emissionColor.xyz*emissionColor.w,0.f.xxx,1.f.xxx), 0.f.xxx);
                    //gSignal.xyz += i > 0 ? gEnergy.xyz * emissionColor.xyz * emissionColor.w : 0.f.xxx;
                    //gEnergy *= max(i > 0 ? max(diffuseColor.xyz - clamp(emissionColor.xyz*emissionColor.w,0.f.xxx,1.f.xxx), 0.f.xxx) : 1.f.xxx, 0.f.xxx);
                };
            }};
            [[flatten]] if (depth == sdepth) { // Light Sphere
                gSignal.xyz += lightc*gEnergy.xyz, gEnergy *= 0.f.xxx;
                gNormal.xyz = normalize((origin.xyz + raydir.xyz * sdepth) - sphere.xyz);
            };

            // 
            origin.xyz += raydir.xyz * depth;
            if (i == 0u) { 
                forign = origin.xyz, 
                fnorml = PrimaryRay.normals.xyz;
                frefl = reflectionPower;
            };

            // 
            if (couldReflection) afterReflection = true;

            // 
            gNormal.xyz = faceforward(gNormal.xyz,raydir.xyz,gNormal.xyz); // interverse into incoming ray
            if (diffuseColor.w > 0.001f) { // Reflection
                raydir.xyz = (i == 0 && I == 1 || couldReflection) ? reflectGlossy(raydir.xyz, gNormal.xyz, seed, specularColor.y) : randomHemisphereCosine(gNormal.xyz,seed);
            } else { // Fully Transparent, Continue...
                raydir.xyz = normalize(raydir.xyz); 
                if (TRANSPARENT_ITERATION > 0) { TRANSPARENT_ITERATION--; i--; };
            };
            origin.xyz += faceforward(gNormal.xyz,-raydir.xyz,gNormal.xyz) * 0.0001f;
            if (dot(gEnergy.xyz,1.f.xxx) <= 0.0001f || depth >= 9999.f) { break; }; // 

        } //else {
            //gSignal.xyz += fma(gEnergy.xyz, 1.f.xxx,gSignal.xyz), gEnergy *= 0.f;
            //forign.xyz = 0.f.xxx;
        //};

        // 
        //gSignal = vec4(raydir.xyz*0.5f+0.5f,1.f);

        if (I == 0) { // Store for Diffuse
            const vec4 directSample = imageLoad(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy));
            const vec4 locateSample = imageLoad(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy));
            imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), gSignal);
            //imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), gSignal + directSample);
            imageStore(writeImages[SAMPLING], ivec2(gl_LaunchIDNV.xy), vec4(forign,1.f));
            imageStore(writeImages[NORMALED], ivec2(gl_LaunchIDNV.xy), vec4(fnorml,1.f));
        };

        if (I == 1) { // Titanic OS
            imageStore(writeImages[REFLECTS], ivec2(gl_LaunchIDNV.xy), vec4(gSignal.xyz,frefl));
        };

        subgroupBarrier();
    };

    //imageStore(writeImages[DIFFUSED], ivec2(gl_LaunchIDNV.xy), vec4(1.f,0.75f,0.f,1.f));
};
